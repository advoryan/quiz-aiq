<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recommendation Spin Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #wheel-container {
            position: relative;
            width: 300px;
            height: 300px;
        }
        #wheel {
            width: 100%;
            height: 100%;
            transition: transform 3s ease-out;
            border-radius: 50%;
            border: #2e7d32 solid 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 2px 10px rgba(0,0,0,0.2));

        }
    #wheel-canvas {
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 50%;
    }
        /* Pointer indicator at the top */
        .pointer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translate(110px, 60px) rotate3d(0, 0, 1, 0deg);
            width: 0;
            height: 0;
            border-left: 25px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 25px solid #ff6200;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5));
            z-index: 2;
        }
        #spin-button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #ff6200;
            color: white;
            border: none;
            border-radius: 5px;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5));

        }
        #spin-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .modal {
            background: #fff;
            width: 90%;
            max-width: 420px;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .modal h2 { margin: 0 0 8px; font-size: 22px; }
        .modal p { margin: 0 0 16px; color: #444; }
        .modal form { display: grid; gap: 10px; }
        .modal label { font-size: 14px; color: #333; }
        .modal input {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        .modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }
        .btn {
            padding: 10px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }
        .btn.primary { background: #ff6200; color: #fff; }
        .btn.ghost { background: #f0f0f0; color: #333; }

        /* Confetti canvas overlay */
        #confetti-canvas {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 9;
        }
    </style>
</head>
<body>
  <div id="wheel-container">
    <div class="pointer"></div>
    <div id="wheel">
  <canvas id="wheel-canvas"></canvas>
    </div>
  </div>
  <button id="spin-button">Spin to Win!</button>

  <!-- Confetti -->
  <canvas id="confetti-canvas"></canvas>

  <!-- Claim Modal -->
  <div id="claim-backdrop" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="claim-title">
      <h2 id="claim-title">You won!</h2>
      <p id="claim-prize-text">Prize: ...</p>
      <form id="claim-form">
        <div>
          <label for="email">Email</label>
          <input id="email" name="email" type="email" placeholder="Enter your email" required>
        </div>
        <div>
          <label for="phone">Phone</label>
          <input id="phone" name="phone" type="tel" placeholder="Enter your phone" pattern="[0-9+()\-\s]{7,}" required>
        </div>
        <div>
          <label for="zip">ZIP</label>
          <input id="zip" name="zip" type="text" placeholder="Enter your ZIP" pattern="[A-Za-z0-9\-\s]{3,10}" required>
        </div>
        <div class="modal-actions">
          <button type="submit" class="btn primary">Claim prize</button>
          <button type="button" id="close-modal" class="btn ghost">Close</button>
        </div>
      </form>
      <p id="claim-status" style="display:none; color:#2e7d32; font-weight:600; margin-top:8px;">Thank you! We received your info.</p>
    </div>
  </div>

  <script>
  const wheel = document.getElementById('wheel');
  const wheelCanvas = document.getElementById('wheel-canvas');
  const wctx = wheelCanvas.getContext('2d');
    const spinButton = document.getElementById('spin-button');
    const backdrop = document.getElementById('claim-backdrop');
    const prizeTextEl = document.getElementById('claim-prize-text');
    const closeModalBtn = document.getElementById('close-modal');
    const claimForm = document.getElementById('claim-form');
    const claimStatus = document.getElementById('claim-status');
    const confettiCanvas = document.getElementById('confetti-canvas');

    // Configure your 12 section labels here (editable)
    const prizes = [
      "10% OFF",
      "Free Shipping",
      "$5 Gift Card",
      "Bonus Points",
      "Try Again",
      "Mystery Gift",
      "2x Rewards",
      "VIP Access",
      "Surprise!",
      "15% OFF",
      "Free Sample",
      "$10 Voucher"
    ];

  let isSpinning = false;
    let currentAngle = 0; // Keep the wheel where it stopped
  let firstWinDone = localStorage.getItem('firstWinDone') === '1';

    // --- Canvas wheel rendering (no SVG) ---
    function drawWheel(labels) {
      const n = labels.length;
      const anglePer = (Math.PI * 2) / n;
      // Fit canvas to element with devicePixelRatio for crispness
      const size = Math.min(wheel.clientWidth, wheel.clientHeight);
      const dpr = window.devicePixelRatio || 1;
      wheelCanvas.width = Math.max(1, Math.floor(size * dpr));
      wheelCanvas.height = Math.max(1, Math.floor(size * dpr));
      wheelCanvas.style.width = size + 'px';
      wheelCanvas.style.height = size + 'px';
      wctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const cx = size / 2;
      const cy = size / 2;
      const radius = size / 2 - 6; // leave some padding inside border

      // Background circle
      wctx.clearRect(0, 0, size, size);
      wctx.save();
      wctx.translate(cx, cy);
      wctx.beginPath();
      wctx.arc(0, 0, radius + 3, 0, Math.PI * 2);
      wctx.fillStyle = '#ffffff';
      wctx.fill();
      wctx.restore();

      // Colors for slices
      const colors = ['#ffcc00','#ff8a65','#81c784','#64b5f6','#ba68c8','#4db6ac'];

      // Start so index 0 is centered at top (pointer at 12 o'clock)
      const startOffset = -Math.PI / 2;

      for (let i = 0; i < n; i++) {
        const start = startOffset + i * anglePer;
        const end = start + anglePer;
        // Slice
        wctx.beginPath();
        wctx.moveTo(cx, cy);
        wctx.arc(cx, cy, radius, start, end);
        wctx.closePath();
        wctx.fillStyle = colors[i % colors.length];
        wctx.fill();
        // Divider
        wctx.strokeStyle = 'rgba(255,255,255,0.9)';
        wctx.lineWidth = 2;
        wctx.stroke();

        // Label along the radial center line of the slice
        const mid = start + anglePer / 2;
        wctx.save();
  wctx.translate(cx, cy);
  // First, align to the slice's radius for correct position
  wctx.rotate(mid);
  // Position at the radial center between hub and rim
  const rCenter = radius * 0.58;
  wctx.translate(rCenter, 0);
  // Then, flip only the text orientation if upside down (do not affect position)
  const absMid = ((mid % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
  const orient = (absMid > Math.PI / 2 && absMid < 3 * Math.PI / 2) ? Math.PI : 0;
  wctx.rotate(orient);

        // Font sizing with auto-shrink to fit a max width
        const baseFont = Math.min(18, Math.max(10, Math.floor(radius * 0.11)));
        let fontSize = baseFont;
        const text = String(labels[i]);
        wctx.font = `600 ${fontSize}px Arial, sans-serif`;
        let width = wctx.measureText(text).width;
        const maxWidth = radius * 0.8; // available length along the radial line
        if (width > maxWidth) {
          const scale = Math.max(0.6, maxWidth / width);
          fontSize = Math.max(8, Math.floor(baseFont * scale));
          wctx.font = `600 ${fontSize}px Arial, sans-serif`;
        }

        wctx.fillStyle = '#1a1a1a';
        wctx.textAlign = 'center';
        wctx.textBaseline = 'middle';
        wctx.fillText(text, 0, 0);
        wctx.restore();
      }

      // Center hub
      wctx.beginPath();
      wctx.arc(cx, cy, Math.max(14, radius * 0.12), 0, Math.PI * 2);
      wctx.fillStyle = '#ffffff';
      wctx.fill();
      wctx.lineWidth = 3;
      wctx.strokeStyle = 'rgba(0,0,0,0.15)';
      wctx.stroke();
    }

    // Initial draw and on resize
    function redraw() { drawWheel(prizes); }
    window.addEventListener('resize', redraw);
    // Defer initial draw to ensure layout is settled
    requestAnimationFrame(redraw);

    // Simple confetti implementation
    const confetti = (() => {
      const ctx = confettiCanvas.getContext('2d');
      let W = confettiCanvas.width = window.innerWidth;
      let H = confettiCanvas.height = window.innerHeight;
      let pieces = [];
      let running = false;

      window.addEventListener('resize', () => {
        W = confettiCanvas.width = window.innerWidth;
        H = confettiCanvas.height = window.innerHeight;
      });

      function randomColor() {
        const colors = ['#f94144','#f3722c','#f8961e','#f9844a','#f9c74f','#90be6d','#43aa8b','#577590'];
        return colors[Math.floor(Math.random()*colors.length)];
      }

      function spawn(n = 120) {
        pieces = Array.from({length: n}).map(() => ({
          x: Math.random()*W,
          y: -20 - Math.random()*H*0.5,
          w: 8 + Math.random()*6,
          h: 8 + Math.random()*10,
          r: Math.random()*2*Math.PI,
          vX: -1 + Math.random()*2,
          vY: 2 + Math.random()*3,
          vR: -0.1 + Math.random()*0.2,
          color: randomColor()
        }));
      }

      function draw() {
        ctx.clearRect(0,0,W,H);
        pieces.forEach(p => {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.r);
          ctx.fillStyle = p.color;
          ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
          ctx.restore();
          p.x += p.vX; p.y += p.vY; p.r += p.vR;
          if (p.y > H + 20) p.y = -20;
          if (p.x < -20) p.x = W + 20; if (p.x > W + 20) p.x = -20;
        });
      }

      function loop() {
          if (!running) return;
          draw();
          requestAnimationFrame(loop);
      }

      return {
        start(durationMs = 360000) {
          spawn(); running = true; loop();
          setTimeout(() => { running = false; ctx.clearRect(0,0,W,H); }, durationMs);
        }
      };
    })();

    function openModal(prizeText) {
      prizeTextEl.textContent = `Prize: ${prizeText}`;
      backdrop.style.display = 'flex';
      backdrop.setAttribute('aria-hidden', 'false');
    }

    function closeModal() {
      backdrop.style.display = 'none';
      backdrop.setAttribute('aria-hidden', 'true');
    }

    spinButton.addEventListener('click', () => {
      if (isSpinning) return;
      isSpinning = true;
      spinButton.disabled = true;

      // Choose prize and compute target angle without resetting after stop
      const randomRotations = Math.floor(Math.random() * 3) + 3; // 3-5 full spins
      // Guarantee a win on the very first spin (deterministic prize index 0)
      const prizeIndex = firstWinDone ? Math.floor(Math.random() * prizes.length) : 0;
  const anglePerPrize = 360 / prizes.length;
      // Offset so the chosen prize lands under the pointer (top, 0deg)
      const prizeAngle = prizeIndex * anglePerPrize + anglePerPrize / 2; // center of segment
      const targetAngle = currentAngle + randomRotations * 360 + (360 - (currentAngle % 360) - prizeAngle);

      // Ensure transition is enabled for spinning
      wheel.style.transition = 'transform 3s ease-out';
      wheel.style.transform = `rotate(${targetAngle}deg)`;

      const onEnd = () => {
        wheel.removeEventListener('transitionend', onEnd);
        // Normalize angle instantly without additional rotation
        const normalized = ((targetAngle % 360) + 360) % 360;
        wheel.style.transition = 'none';
        wheel.style.transform = `rotate(${normalized}deg)`;
        // Force reflow so next set transition takes effect
        void wheel.offsetWidth;
        currentAngle = normalized;

        // Celebrate and show claim modal
        confetti.start(4500);
        setTimeout(() => {
          openModal(prizes[prizeIndex]);
          if (!firstWinDone) {
            firstWinDone = true;
            localStorage.setItem('firstWinDone', '1');
          }
        }, 1000);

        isSpinning = false;
        // Keep button disabled while modal is open to encourage claiming
      };
      wheel.addEventListener('transitionend', onEnd);
    });

    closeModalBtn.addEventListener('click', () => {
      closeModal();
      spinButton.disabled = false;
    });

    claimForm.addEventListener('submit', (e) => {
      e.preventDefault();
      // Simulate submit
      claimStatus.style.display = 'block';
      setTimeout(() => {
        claimStatus.style.display = 'none';
        closeModal();
        spinButton.disabled = false;
      }, 1200);
    });
  </script>
</body>
</html>